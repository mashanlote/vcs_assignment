### Опыт, навыки
См. на странице домашнего задания.

### Цели

Основная цель -- закрыть пробелы в знаниях, которые у меня имеются. В данном курсе меня больше всего интересуют следующие модули: CI/CD, безопасность приложений, многопоточность и асинхронное взаимодействие. Это связано с тем, что это во многом эти темы изучались самостоятельно и я хотел бы получить фидбэк на моё понимание данных тем. 

В конце хочется сдать курсовой проект, который будет лучше (пусть, возможно, и меньше по масштабу), чем те, что я создавал до этого. Подробнее об этом в соответствующем пункте.

### Желаемый курсовой проект

На курсах Тинькофф Финтех по фронтенду я защитил курсовой проект, суть которого заключалась в создании сайта, 
позволяющего пользователям сравнивать песни друг с другом, таким образом определяя ELO-рейтинги песен. 
Так как курс был по фронтенд-разработке, я потратил больше времени на работу над фронтендом, 
и в силу этого мой бэкенд содержал большое количество досадных промахов, которые я хотел бы исправить.

Для этого я хотел бы начать с работы над одним конкретным компонентом, работа над которым, как мне кажется, может быть
рассмотрена как полноценная курсовая работа.

Исходный код проекта в том виде, в котором я сдал его при защите курсовой на курсах фронтенда
можно посмотреть по [ссылке](https://github.com/mashanlote/musicbattle) (нужно запросить права).
У проекта есть более полное описание в файле Readme.md.

> TLDR: Хочу создать Content Management System, которая позволит подгружать и **редактировать** информацию об исполнителях, 
> альбомах, песнях и обложках альбомов в собственную базу данных, запрашивая данные в сторонних API.

Для функционирования сайта мне нужны как минимум следующие данные:
- Название песни
- Исполнитель
- Название альбома, содержащего песню (причём не более одного!)
- Обложка альбома

Для решения данной проблемы я вижу два подхода: 
- использование чужой базы данных, возможно, через публичный API
- ручное внесение данных через CMS

У меня использовался по сути первый подход: я ходил по API в чужую базу данных, обрабатывал полученные данные и сохранял их в собственной БД.
К сожалению, у данного подхода выявилось один существенный недостаток -- несоответствие моего понимания альбома ни одной из имеющихся в открытом доступе баз данных.
Для моего проекта альбомами считаются СТУДИЙНЫЕ альбомы + некоторые значимые релизы, не являющиеся таковыми.

Есть несколько открытых баз данных, которые в теории можно использовать:
1. MusicBrainz
    - Самая близкая к моему пониманию.
    - Содержит следующие сущности:
      - Исполнитель
      - Релизная группа (моё понимание альбома) -- совокупность всех релизов одного альбома, то есть с учетом релизов в разных странах, специальных изданий и т.п.
      - Конкретный релиз -- нужно учитывать, что релизы одного и того же альбома могут содержать иногда разные песни (об этом подробнее позже)
      - Запись -- совокупность всех* версий одной песни, которые встречаются в разных релизах
      - Трек/песня -- конкретная запись, встречающаяся на конкретном релизе
    - Для использования этой БД нужно совершить ремаппинг альбомов и треков 
    - Содержит в той или иной степени фильтры, позволяющие определить, является ли альбом студийным
    - Имеется API с достаточно суровым рейт-лимитом
    - Можно поставить своё зеркало сервера с базой данных (80+ гб), чтобы не тревожить публичный API
    - То, что я в итоге и использовал
2. Discogs
   - Содержит сущности:
     - Исполнитель
     - Альбомы -- не обладает достаточными фильтрами, чтобы отсеять только студийные, но содержит треклист с первого* издания альбома
     - Версии альбомов -- содержат свои собственные треклисты
   - Песни как таковые отсутствуют (?)
3. Last.fm
   - Устаревший API с неопределенным рейт-лимитом
   - Много грязных данных: дублирующиеся исполнители, одна запись для разных исполнителей с одним именем и др.
4. Rate Your Music
   - Самая адекватная с точки зрения разделения исполнителей, альбомов и треков, но...
   - Отсутствует API, а скрейпинг против ToS, нужно уважать :)

В итоге для наполнения своей собственной базы данных я использовал MusicBrainz API примерно в таком порядке:
1. Искал исполнителя по имени и в ответ получал список исполнителей, содержащих введенный паттерн
1. В полученном списке исполнителей выбирал исполнителя с максимальным процентом мэтча (ср. Radiohead и Radiohead3).
1. Для конкретного исполнителя получал список релизных групп, соответствующих студийным альбомам
1. Для каждой релизной группы получал список релизов
1. Для каждого релиза получал список треков

В таком виде мне нужно было сделать ремаппинг РЕЛИЗОВ, содержащих конкретные треки, в некоторое моё представление альбомов, 
то есть найти такие треки, которые являются общими для всех релизов, а также взять все возможные дополнительные треки, 
встречающиеся на разных релизах, и выбрать те, которые встречаются чаще других.
Я решил сделать это автоматически, то есть без моего прямого участия.
Оказалось, что это сделать сложно, потому что:
1. В названиях песен на разных релизах всегда будут ошибки (и это не вина человека, вводившего данные в БД)
   - Например, у Pavement на разных релизах одна и та же песня называется как [Silence Kid и Silence Kit](https://musicbrainz.org/recording/e8bf9b03-6ebf-4d8e-ae30-981eb7083834)
   - Знаки препинания очень часто создают [значительное количество треков, отличающихся только пунктуацией](https://musicbrainz.org/recording/71dcee37-6eb3-4bc6-8db0-34b38cb11352)
2. Названия треков в некоторых странах переводятся на местный язык (например, японский), что требует Fuzzy-matching'а, чтобы не допустить копий треков.
3. Нельзя взять самый первый релиз за основу (и уже от него искать дополнительные треки), потому что:
   - Порядок выхода альбомов не гарантирован! Нам может попасться первым японское издание.
   - Не всегда у релизов есть точно известная дата выхода
4. Для различения специальных изданий, содержащих дополнительные песни нельзя использовать количество дисков как фильтр:
   - Нельзя считать, что первый релиз всегда содержит только один диск, например, The Beatles - The White Album или LCD Soundsystem - LCD Soundsystem
   - Альбомы могут выйти сначала на нескольких дисках, а потом переиздаться на одном: Minutemen - Double Nickels on the Dime 
5. Нельзя гарантировать, что существенно различающиеся названия означают разные песни: Radiohead - Hail to the Thief с его дополнительными названиями в скобках
6. Нельзя гарантировать, что если название трека с одного релиза является частью названия с другого релиза 
(например, ожидая, что удлиненное название связано со словом "Remastered"), то это означает, что это одни трек. 
Например, Two Headed Boy и Two Headed Boy, pt. 2 -- очевидным образом разные песни.
7. На одном альбоме может быть несколько разных песен с одним названием (что с этим делать?!),
например, [(Something)](https://musicbrainz.org/release/3d341648-5aee-4128-805a-a9a0efd7a6f3).
6. Ну и ещё тысяча способов, о которых я не догадываюсь, как что-то может пойти не так.

А ещё нужно выбрать только одну самую репрезентативную обложку для каждого альбома...

Это означает, что базу данных нужно заполнять самому. 
Но полностью вручную это делать, конечно же, не хочется, поэтому я хотел бы создать своего рода CMS для безболезненного наполнения базы данных.

В теории, она будет позволять:
- Запрашивать информацию о списках исполнителей, релизных группах конкретного исполнителя, треклистах разных релизов и т.п. через 
MusicBrainz API (а, возможно, делая запрос к собственному зеркалу MusicBrainz) и отдавать нужные данные на фронтенд
- Администратор сможет добавлять отдельных исполнителей в БД
- Сможет связывать альбомы и исполнителей, выполняя работу по отбору нужных песен вручную.
  - Таким образом, можно добавлять не только студийные альбомы, но и некоторые другие значимые релизы (типа Fugazi - 13 Songs и Jeff Buckley - Sketches for My Sweetheart the Drunk)
- Связать альбом с его обложкой

Это задача в идеале требует некоторой фронтовой части, но кажется (для защиты курсовой по бэкенду), 
что можно обойтись и просто набором ручек для соответствующих действий :) Но минимальную админскую панель тоже хотелось бы сделать.
Дополнительно хотелось бы:
   - Оформить это как полноценный RESTful-бэкенд, обрабатывающий все возможные ошибки, и выдающий нужные коды ответов на все типы запросов.
   - Использовать Swagger/OpenAPI для описания ручек и, возможно, их генерации (?)
   - Сопроводить всё тестами
   - Обвесить всё это CI/CD, чтобы сборка/тестирование/деплой проекта не приходилось делать вручную
   - Использовать скрипты миграций для версионирования БД (на всякий случай)
   - Настроить права доступа к ручкам через Spring Security
   - и т.д.

Вообще в рамках работы над сервисом в целом хотелось бы также:
- Вынести логику авторизации в отдельный сервис
- Сохранять историю оценок пользователей в Кафку (?)
- Возвращать информативную статистику с бэкенда 
- ...

Но я хотел бы сфокусироваться сначала на вопросе заполнения базы данных.

### Основные команды git

- init
> Создаёт репозиторий в текущей папке: 
> создаёт в ней невидимую папку `.git`, хранящую необходимые для версионирования данные. 
> Достаточно использовать в директории без git-проекта ```git init```.
- clone
> Позволяет скопировать удалённый (но, возможно, находящийся на том же компьютере) репозиторий в текущую папку.
> Чтобы сохранить данный репозиторий, можно использовать ```git clone git@github.com:mashanlote/vcs_assignment.git```
- add
> Добавляет новый файл/файл с изменениями в staging area.
> ```git add Readme.md```
- commit
> Фиксирует состояние рабочей директории: берёт предыдущее зафиксированное состояние директории и применяет к нему изменения,
> имеющиеся в staging area. Состояние рабочей директории на момент комита будет доступно по хэшу. 
> ```git commit -m 'My first commit'```
- push
> Отправляет историю коммитов текущей/указанной ветки в удаленный репозиторий.
> ```git push origin master``` передаст и обновит историю коммитов локальной ветки мастер в удаленный репозиторий под названием origin.
- pull
> Получает историю коммитов текущей/указанной ветки из удаленного репозитория.
> ```git pull origin master``` получает историю из ветки master удаленного репозитория под названием origin и обновляет историю комитов текущей ветки.



